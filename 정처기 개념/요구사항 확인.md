# 요구사항 확인 
p.26

## 소프트웨어 생명 주기
소프트웨어 생명 주기(Software Life Cycle) : 소프트웨어를 개발하기 위한 과정을 각 단계별로 나눈 것

**생명 주기 모형**
- 폭포수 모형(Waterfall Model) 
  : 각 단계를 확실히 매듭짓고 그 결과를 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론
  ,  *고전적 생명 주기 모형*
- 프로토타입 모형(Prototype Model)
  : 실제 개발될 소프트웨어 견본품을 만들어 최종 결과물을 예측하는 모형 
- 나선형 모형(Spiral Model)
  : 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 개발하는 모형
  , *폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형*
  ```
  4가지 주요 활동
  계획수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가
  ```
- 애자일 모형(Agile Model)
  : 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형, *폭포수 모형과 대조적*

### 애자일 개발 4가지 핵심 가치
- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다
- 방대한 문서보다는 실행되는 SW에 더 가치를 둔다
- 계약 협상보다는 고객과 협업에 더 가치를 둔다
- 계획을 따르기보다는 변화에 반응하는 것에 더 가치를 둔다.

### 소프트웨어 공학
소프트웨어 공학 : 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문

**소프트웨어 공학의 기본 원칙**
- 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
- 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
- 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.  

#

## 애자일 개발 모형

### 1. 스크럼(Scrum) 기법
팀이 중심이 되어 개발의 효율성을 높이는 기법

    스크럼 팀
    - 제품 책임자(PO) : 요구사항이 담긴 백로그를 작성하는 주체
    - 스크럼 마스터(SM) : 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행함
    - 개발팀(DT) : 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발을 수행함

    
    스크럼 개발 프로세스
    계획 -> 진행(스프린트) -> 스프린트 회의&검토 -> 스프린트 회고

### 2. XP(eXtreme Programming) 기법
요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상시키는 방법
    
    XP의 5가지 핵심 가치
    - 의사소통, 단순성, 용기, 존중, 피드백
    

    XP 개발 프로세스
    릴리즈 계획 -> 이이터레이션 -> 승인 검사(인수 테스트) -> 소규모 릴리즈
    

    XP의 주요 실천 방법
    - Pair Programming(짝 프로그래밍)
      : 개발에 대한 책임을 공동으로 나눠 갖는 환경 조성
    - Collective Ownership(공동 코드 소유)
      : 개발 코드에 대한 권한과 책임을 공동으로 소휴
    - Test-Driven Development(테스트 주도 개발)
      : 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하여 자신이 무엇을 해야할지 정확히 파악 후 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 사용
    - Whole Team(전체 팀)
      : 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함
    - Continuous Integration(계속적인 통합)
      : 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합
    - Refactoring(리팩토링)
      : 프로그램 기능의 변경 없이 시스템 재구성
    - Small Releases(소규모 릴리즈)
      : 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속하게 대응

### 3. 칸반
### 4. Lean
### 5. 기능 중심 개발(FDD)  
  
#
  
## 개발 기술 환경 파악

### 운영체제(OS, Operating System)
컴퓨터 시스템의 자원을 효율적으로 관리하며, 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어

    운영체제 관련 요구사항 식별 시 고려사항
    - 가용성
    - 성능
    - 기술 지원
    - 주변 기기
    - 구축 비용

### 데이터베이스 관리 시스템(DBMS; DataBase Management System)
사용자와 데이터베이스 사이에서 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어

    DBMS 관련 요구사항 식별 시 고려사항
    - 가용성
    - 성능
    - 기술 지원
    - 상호 호환성
    - 구축 비용

### 웹 애플리케이션 서버(WAS; Web Application Server)
동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어

    웹 애플리케이션 서버 관련 요구사항 식별 시 고려사항
    - 가용성
    - 성능
    - 기술 지원
    - 구축 비용

### 오픈 소스(Open Source)
제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어

    오픈소스 관련 요구사항 식별 시 고려사항
    - 라이선스의 종류
    - 사용자 수
    - 기술의 지속 가능성  
  
#

## 요구사항 정의
 
### 요구사항 : 소프트웨어가 어떤 문젤르 해결하기 위해 제공하는 서비스에 대한 설명과 운영에 필요한 제약조건

    요구사항의 유형
    - 기능 요구사항 : 기능이나 수행과 관련된 요구사항
                    시스템이 반드시 수행해야 하는 기능
    - 비기능 요구사항 : 품질이나 제약사항과 관련된 요구사항
                     성능 요구사항, 인터페이스 요구사항 등
    - 사용자 요구사항 : 사용자 관점에서 본 시스템이 제공해야 할 요구사항
    - 시스템 요구사항 : 개발자 관점에서 본 시스템 전체가 제공해야 할 요구사항
  
### 요구사항 개발 프로세스 
요구사항을 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 활동

    요구사항 개발 프로세스
    - 도출 -> 분석 -> 명세 -> 확인

### 요구사항 도출
시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 식별하고 이해하는 과정

    요구사항을 도출하는 주요 기법
    - 청취와 인터뷰
    - 설문
    - 브레인스토밍 : 3인 이상이 자유롭게 의견을 교환하면서 독창적인 아이디어를 도출해 내는 방법
    - 워크샵
    - 프로토타이핑 : 프로토타입을 통해 효과적으로 요구 분석을 수행하면서 명세서를 산출하는 작업
    - 유스케이스 : 사용자의 요구사항을 기능 단위로 표현하는 것

### 요구사항 분석
요구사항 중 이해되지 않는 부분을 걸러내기 위한 과정  
개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동

    구조적 분석 기법
    : 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법
    
    요구사항 분석에 사용되는 대표적인 도구
    - 자료 흐름도(DFD) : 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
                       - 자료 흐름 그래프, 버블 차트
                       - 구조적 분석 기법에 이용됨
                       - 프로세스, 자료 흐름, 자료 저장소, 단말
    - 자료 사전(DD) : 자료 흐름도에 있는 자료를 정의하고 기록한 것
                    - 데이터의 데이터 또는 메타 데이터
                    - = : 자료의 정의
                    - + : 자료의 연결
                    - ( ) : 자료의 생략
                    - [ ] : 자료의 선택
                    - { } : 자료의 반복
                    - * * : 자료의 설명(주석)
    
    요구사항 분석용 CASE(자동화 도구) : 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구
    - SADT : 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구
    - SREM = RSL/REVS : TRW 사가 실시간 처리 소프트웨어 시스템에서 요구사항을 명확하게 기술하도록 할 목적으로 개발한 도구
    - PSL/PSA : PSL과 PSA를 사용하는 자동화 도구, 미시간 대학에서 개발
    - TAGS : 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구

    HIPO(Hierachy Input Process Output) : 시스템 실행 과정인 입력·처리·출력의 기능을 표현한 것
            - 하향식 소프트웨어 개발을 위한 문서화 도구
            - 기호, 도표 등을 사용하므로 보기 쉽고 이해하기 쉬움
    
    HIOP Chart의 종류
    - 가시적 도표
    - 총체적 도표
    - 세부적 도표


### 요구사항 명세
분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것

### 요구사항 확인(요구사항 검증)
요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동

### 요구공학
요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문

    요구사항 명세 기법
    - 정형 명세 기법
      기법 : 수학적 원리 기반, 모델 기반
      작성 방법 : 수학적 기호, 정형화된 표기법
      특징 : 요구사항을 정확하고 간결하게 표현할 수 있음
            사용자가 이해하기 어려움
      종류 : VDM, Z, Petri-net, CSP 등
    
    - 비정형 명세 기법
      기법 : 상태/기능/객체 중심
      작성방법 : 자연어 기반, 다이어그램
      특징 : 일관성이 떨어지고, 해석이 달라질 수 있음
            내용의 이해가 쉬어 의사소통이 용이함
      종류 : FSM, Decision Table, ER모델링, State Chart(SADT) 등
  
#

## UML(Unified Modeling Language)의 개요

### UML
: 시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어

#### UML의 구성요소
- 사물(Things) : 다이어그램 안에서 관계가 형성될 수 있는 대상들, 모델을 구성하는 가장 중요한 요소
    ```
    - 구조 사물(Structural Things) : 시스템의 개념적, 물리적 요소 표현
                                  클래스, 유스케이스, 컴포넌트, 노드 등
    - 행동 사물(Behavioral Things) : 시간과 공간에 따른 요소들의 행위 표현
                                    상호작용, 상태 머신 등
    - 그룹 사물(Grouping Things) : 요소들을 그룹으로 묶어서 표현
                                  패키지
    - 주해 사물(Annotation Things) : 부가적인 설명이나 제약조건 등 표현
                                    노트
    ```
- 관계(Relationships) : 사물과 사물 사이의 연관성을 표현하는 것
    ```
    - 연관(Association) 관계 : 2개 이상의 사물이 서로 관련되어 있는 관계
                              실선으로 표현
    - 집합(Aggregation) 관계 : 하나의 사물이 다른 사물에 포함되어 있는 관계
                              포함하는 쪽과 포함되는 쪽은 서로 독립적, 실선(속이 빈 마름모)으로 표현
    - 포함(Composition) 관계 : 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
                              실선(속이 채워진 마름모)으로 표현
    - 일반화(Generalization) 관계 : 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
                                  실선(속이 빈 화살표)으로 표현
    - 의존(Dependency) 관계 : 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
                            점선 화살표로 표현
    - 실체화(Realization) 관계 : 할 수 있거나 해야 하는 기능으로, 서로를 그룹화 할 수 있는 관계
                               속이 빈 점선 화살표로 표현
    ```
- 다이어그램(Diagram) : 사물과 관계를 도형으로 표현하는 것
    ```
    정적 모델링 - 구조적 다이어그램
    동적 모델링 - 행위 다이어그램

    구조적 다이어그램의 종류 
    - 클래스(Class) 다이어그램 : 클래스 사이의 관계 표현
    - 객체(Object) 다이어그램 : 객체와 객체 사이의 관계로 표현, 럼바우 - 객체 모델링에 활용
    - 컴포넌트(Component) 다이어그램 : 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스 표현
    - 배치(Deployment) 다이어그램 : 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치 표현
    - 복합체(Composite) 구조 다이어그램 : 북합 구조를 갖는 클래스나 컴포넌트의 내부 구조 표현
    - 패키지(Package) 다이어그램 : 모델 요소들을 그룹화한 패키지들의 관계 표현

    행위 다이어그램의 종류
    - 유스케이스(Use Case) 다이어그램 : 사용자의 요구 분석, 기능 모델링 작업에 사용
    - 시퀀스(Sequence) 다이어그램 : 상호 작용하는 시스템이나 객체들이 주고받는 메시지 표현
    - 커뮤니케이션(Communication) 다이어그램 : 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계 표현
    - 상태(State) 다이어그램 : 객체가 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현, 럼바우 - 동적 모델링에 활용
    - 활동(Activity) 다이어그램 : 객체의 처리 로직이나 조건에 따른 처리의 시스템 흐름을 순서에 따라 표현
    - 상호작용 개요(Interaction Overview) 다이어그램 : 상호작용 다이어그램 간의 제어 흐름 표현
    - 타이밍(Timing) 다이어그램 : 객체 상태 변화와 시간 제약을 명시적으로 표현

    스테레오 타입(Stereotype) : UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것
                            - 겹화살괄호(≪≫) 사이에 표현할 형태 기술
        주로 표현되는 형태
        - ≪include≫ : 포함 관계에 있는 경우
        - ≪extends≫ : 확장 관계에 있는 경우
        - ≪interface≫ : 인터페이스를 정의하는 경우
        - ≪exception≫ : 예외를 정의하는 경우
        - ≪constructor≫ : 생성자 역할을 수행하는 경우
    ```
  
#

## 기능 모델링
: 개발될 시스템이 갖춰야 할 기능을 사용자와 공유하기 위해 그림으로 표현하는 것

### 유스케이스 다이어그램 
: 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것  
  시스템의 범위를 파악할 수 있음  
  사용자의 요구사항을 분석하기 위한 도구로 사용됨
  ```
  유스케이스 다이어그램 구성 요소
  - 시스템/시스템 범위 : 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현한 것
  - 액터 : 시스템과 상호작용을 하는 모든 외부 요소
  - 유스케이스 : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것
  - 관계 : 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타나는 관계, 포함/확장/일반화 관계
  ```

### 활동 다이어그램
: 사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것
  ```
  활동 다이어그램 구성 요소
  - 액션/액티비티 : 액션 - 더이상 분해할 수 없는 단일 작업, 액티비티 : 몇 개의 액션으로 분리될 수 있는 작업
  - 시작 노드 : 액션이나 액티비티가 시작됨을 표현한 것
  - 종료 노드 : 액티비티 안의 모든 흐름이 종료됨을 표현한 것
  - 노건(판단) 노드 : 조건에 따라 제어의 흐름이 분리됨을 표현한 것
                   들어오는 제어 흐름은 한 개, 나가는 제어 흐름은 여러 개
  - 병합 노드 : 여러 경로의 흐름이 하나로 합쳐짐을 표현한 것
              들어오는 제어 흐름은 여러 개, 나가는 제어 흐름은 한 개
  - 포크 노드 : 액티비티의 흐름이 분리되어 수행됨을 표현한 것
              들어오는 액티비티 흐름은 한 개, 나가는 액티비티 흐름은 여러 개
  - 조인 노드 : 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현한 것
              들어오는 액티비티 흐름은 여러 개, 나가는 액티비티 흐름은 한 개
  - 스윔레인 : 액티비티 수행을 담당하는 주체를 구분하는 선
             가로 또는 세로 실선을 그어 구분함   
  ```

## 정적 모델링    
: 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것

### 클래스 다이어그램
: 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것  
시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램  
시스템 구성 요소를 문서화하는 데 사용
  ```
  클래스 다이어그램의 구성 요소
  - 클래스 : 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현한 것
            클래스의 이름, 속성, 오퍼레이션 표기
  - 제약조건 : 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건
             클래스 안에 제약 조건을 기술할 때는 중괄호{ } 사용
  - 관계 : 클래스와 클래스 사이의 연관성을 표현한 것
          연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계


  연관 클래스 : 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
  ```

## 동적 모델링
: 시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것

### 시퀀스 다이어그램
: 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것  
시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지 표현

  ```
  시퀀스 다이어그램의 구성 요소
  - 액터 : 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 읨
  - 객체 : 메시지를 주고받는 주체
  - 생명선 : 객체가 메모리에 존재하는 기간, 객체 아래쪽에 점선을 그어 표현
  - 실행 상자(활성 상자) : 객체가 메시지를 주고받으며 구동되고 있음을 표현함
  - 메시지 : 객체가 상호 작용을 위해 주고받는 메시지
  - 객체 소멸 : 해당 객체가 더 이상 메모리에 존재하지 않음을 표현한 것
  - 프레임 : 다이어그램의 전체 또는 일부를 묶어 표현한 것
  ```

### 커뮤니케이션 다이어그램
: 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것

  ```
  커뮤니케이션 다이어그램의 구성 요소
  - 액터 : 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템 의미
  - 객체 : 메시지를 주고받는 주체
  - 링크 : 객체들 간의 관계를 표현한 것, 실선으로 표현
  - 메시지 : 객체가 상호 작용을 위해 주고받는 내용
  ```

### 상태 다이어그램
: 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것

  ```
  상태 다이어그램의 구성 요소
  - 상태 : 객체의 상태를 표현한 것
  - 시작 상태 : 상태의 시작을 표현한 것
  - 종료 상태 : 상태의 종료를 표현한 것
  - 상태 전환 : 상태 사이의 흐름, 변화를 화살표로 표현한 것
  - 이벤트 : 상태에 변화를 주는 현상
  - 프레임 : 상태 다이어그램의 범위를 표현한 것
  ```

## 패키지 다이어 그램
: 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것
  ```
  패키지 다이어그램의 구성 요소
  - 패키지 : 객체들을 그룹화한 것
            - 단순 표기법 : 패키지 안에 패키지 이름만 표현
            - 확장 표기법 : 패키지 안에 요소까지 표현
  - 객체 : 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들
  - 의존 관계 : 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현
              - 스테레오 타입을 이용해 구체적으로 표현 가능
              - 표현 형태 : ≪import≫, ≪access≫
  ```
  
#

## 소프트웨어 개발 방법론
: 소프트웨어 개발, 유지보수 등에 필요한 수행 방법과 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것

### 1. 구조적 방법론
: 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론  
복잡한 문제를 다루기 위해 분할과 정복 원리 적용

### 2. 정보공학 방법론
: 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론  
정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합

### 3. 객체지향 방법론
: 객체들을 조립해서 소프트웨어를 구현하는 방법론  
객체지향 방법론의 구성 요소 : 객체, 클래스, 메시지 등  
객체지향 방법론의 기본 원칙 : 캡슐화, 정보은닉, 추상화, 상속성, 다형성 등
  ```
  - 캡슐화(Encapsulation) : 데이터와 데이터를 처리하는 함수를 하나로 묶는 것
  - 정보 은닉(Information Hiding) : 캡슐화에서 가장 중요한 개념, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근 허용
  - 추상화(Abstraction) : 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에 중점을 두어 개략화
  - 상속성(Inheritance) : 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
  - 다형성(Polymorphism) : 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
  ```

### 4. 컴포넌트 기반(CBD) 방법론
: 컴포넌트를 조합하여 새롱누 애플리케이션을 만드는 방법론  
컴포넌트 재사용 가능
유지 보수 비용 최소화, 생산성 및 품질 향상

### 5. 제품 계열 방법론
: 제품에 적용하고 싶은 공통된 기능을 정의하고 개발하는 방법론  
임베디드 소프트웨어를 만드는데 적합  
- 영역공학 : 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
- 응용공학 : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역
  
#

## S/W 공학의 발전적 추세
### 소프트웨어 재사용(Software Reuse)
: 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것  
소프트웨어 개발의 품질과 생산성을 높이기 위한 방법
기존에 개발된 소프트웨어와 경험, 지식 등을 새로운 소프트웨어에 적용

```
소프트웨어 재사용 방법
- 합성 중심(Composition-Based) : 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 블록 구성 방법
- 생성 중심(Generation-Based) : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 패턴 구성 방법
```
  
### 소프트웨어 재공학(Software Reengineering)
: 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것  
유지보수의 생산성을 향상시킴

```
소프트웨어 재공학의 이점
- 소프트웨어의 품질 향상
- 소프트웨어의 생산성 증가
- 소프트웨어의 수명 연장
- 소프트웨어의 오류 감소
```

### CASE(Computer Aided Software Engineering)
: 소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화 하는 것  
소프트웨어 생명 주기의 전체 단계 연결, 자동화하는 통합된 도구 제공  

```
CASE의 주요 기능
- 소프트웨어 생명 주기 전 단계의 연결
- 다양한 소프트웨어 개발 모형 지원
- 그래픽 지원
```
  
#

## 비용 산정 기법

### 하향식 비용 산정 기법
: 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법

```
하향식 비용 산정 기법
- 전문가 감정 기법 : 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법
                  - 가장 편리하고 신속하게 비용 산정
                  - 개인적이고 주관적일 수 있음
- 델파이 기법 : 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법
              - 전문가들의 편견이나 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가로 구성
```


### 상향식 비용 산정 기법
: 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법

```
상향식 비용 산정 기법
- LOC(원시 코드 라인 수) 기법 : 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법  
                            - 측정이 용이하고 이해하기 쉬움
                            - 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용 산정
                            * 산정 공식 
                              - 노력(인월) = 개발 기간 * 투입 인원 = LOC/1인당 월평균 생산 코드 라인 수
                              - 개발 비용 = 노력(인월) * 단위비용(1인당 월평균 인건비)
                              - 개발 기간 = 노력(인월) / 투입 인원
                              - 생산성 = LOC / 노력(인월)
- 개발 단계별 인원수(Effot Per Task) 기법 : 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
                                        - LOC 기법을 보완하기 위한 기법
                                        - LOC 기법보다 더 정확함
- 수학적 산정 기법 : 개발 비용 산정의 자동화를 목표로 함
```

### 수학적 산정 기법
: 상향식 비용 산정 기법

```
- COCOMO 모형 : LOC에 의한 비용 산정 기법
               - 보헴이 제안함
               - 개발할 소프트웨어의 규모를 예측한 후 SW 종류에 따라 닫르게 책정되는 비용 산정 방법
               * COCOMO의 소프트웨어 개발 유형
                - 조직형(Organic Mode) : 5만 라인 이하의 소프트웨어를 개발하는 유형
                - 반분리형(Semi-Detached Mode) : 30만 라인 이하의 소프트웨어를 개발하는 유형
                - 내장형(Embedded Mode) : 30만 라인 이상의 소프트웨어를 개발하는 유형
              * COCOMO 모형의 종류
                - 기본형 COCOMO : 소프트웨어의 크기와 개발 유형만을 이용하여 비용 산정 
                - 중간형 COCOMO : 제품의 특성, 컴퓨터의 특성, 개발 요원의 특성, 프로젝트의 특성에 의해 비용 산정
                - 발전형 COCOMO : 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용 산정
- Putnam 모형 : 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형
               - 푸트남이 제안
               - 생명 주기 예측 모형
               - Ralyeigh-Norden 곡선의 노력 분도로를 기초로 함
               - 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력 감소
- 기능 점수(FP) 모형 : 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고 기능 점수를 구한 후 비용을 산정하는 기법
                    - 알브레히트가 제안함
                    * 소프트웨어 기능 증대 요인
                      - 자료 입력(입력 양식)
                      - 정보 출력(출력 보고서)
                      - 명령어(사용자 질의수)
                      - 데이터 파일
                      - 필요한 외부 루틴과의 인터페이스
```

비용 산정 자동화 추정 도구 
- SLIM : Reyleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발한 자동화 추정 도구
- ESTIMACS : 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구
  
#

## 프로젝트 일정 계획

### PERT(프로그램 평가 및 검토 기술)
: 전체 작업의 상호 관계를 표시하는 네트워크  


### CPM(임계 경로 기법)
: 작업을 나열하고 작업에 필요한 소요 기간을 예축하는데 사용하는 기법  

### 간트 차트
: 프로젝트의 작업 일정을 막대 도표를 이용하여 표시하여 표시하는 프로젝트 일정표  
시간선 차트라고 함  
수평 막대의 길이는 각 작업의 기간을 나타냄
  
#

## 소프트웨어 개발 표준
: 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준

### ISO/IEC 12207 
: ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스  
소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준 제공

### CMMI(능력 성숙도 통합 모델) 
: 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델  
CMMI의 소프트웨어 프로세스 성숙도 : 초기 -> 관리 -> 정의 -> 정량적 관리 -> 최적화

### SPICE(소프트웨어 처리 개선 및 능력 평가 기준)
: 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
  
#

## 소프트웨어 개발 프레임워크
: 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 제공해주는 반제품 형태의 소프트웨어 시스템

```
소프트웨어 개발 프레임워크의 주요 기능
- 예외 처리
- 트랜잭션 처리
- 메모리 공유
- 데이터 소스 관리
- 서비스 관리
- 쿼리 서비스
- 로깅 서비스
- 사용자 인증 서비스

소프트웨어 개발 프레임워크의 종류
- 스프링 프레임워크
- 전자정부 프렝미워크
- 닷넷 프레임워크
```

### **스프링 프레임워크**
: 자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크  
동적인 웹 사이트의 개발을 위해 다양한 서비스 제공  
전자정부 표준 프레임워크의 기반 기술로 사용됨

### **전자정부 프레임워크**
: 대한민국의 공공부문 정보화 사업 시 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크  
응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목적으로 함  
사업별 공통 컴포넌트의 중복 개발 방지

### **닷넷 프레임워크(.NET Framework)**
: Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크

### **소프트웨어 개발 프레임워크의 특성**
**모듈화(Modularity)** : 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킴  
**재사용성(Reusability)** : 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보장이 가능함  
**확장성(Extensibility)** : 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능함  
**제어의 역흐름(Inversion of Control)** : 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성 향상