객체 지향 프로그래밍

[예제](https://www.notion.so/8c0307f13796422e9f73d4e9b1bdb322)

# 객체 지향 프로그래밍(Object-Oriented Programming; OOP)

객체를 기반으로 하는 프로그래밍

## 1. 클래스

객체의 속성과 기능을 코드로 구현한 것

- 클래스를 정의할 때 클래스 이름과 클래스가 가지는 속성(특성)이 필요
- 멤버 변수 : 클래스 속성은 특성이고, 클래스 내부에 변수로 선언하는 것

## 클래스를 정의하는 문법

```java
(접근 제어자) class 클래스 이름 {
		int studentId;   //	멤버 변수;
		public void showStudentId(){   //	멤버 함수(메서드);
				System.out.println(studentId);   
		}
}
```

멤버 변수 : 클래스 내부에 정의된 변수

멤버 함수(메서드) : 클래스 내부에서 멤버 변수를 사용하여 클래스 기능을 구현한 함수

### 클래스 이름 짓는 규칙 : 대문자로 시작

### 클래스패스(Class Path)

클래스를 찾기위한 경로

## 2. 패키지

클래스 파일의 묶음

## 3. 함수

하나의 기능을 수행하는 일련의 코드, 수행할 기능을 미리 구현하고 필요할 때마다 호출

 

### 함수 정의

```java
함수반환형 함수명(매개변수){
		return 반환값;
}
```

- void(함수반환형) : ‘반환할 값이 없다’는 뜻의 예약어

### 예제. 함수 구현하고 호출하기

```java
public vlass FunctionTest{
	public static void main(String[] args) {
		int num1 = 10;
		int num2 = 20;

		int sum = add(num1, num2);  // 함수 호출
		System.out.println(num1 + " + " + num2 + " = " + sum + "입니다.");
	}

	// 함수 구현
	public static int add(int n1, int n2) {
		int result = n1 + n2;
		return result; // 결과값 반환
	}
}
```

### 함수의 장점

1. 기능을 나누어 코드를 효율적으로 구현할 수 있음
    - 기능을 분리해서 구현하면 프로그램 코드의 가독성이 좋아짐
    - 기능별로 구현하면 그 기능의 함수를 호출하면 되므로 편리함
2. 중복되는 코드를 막을 수 있음
3. 프로그램을 실행할 때 생긴 오류를 수정할 때 편리함

### 클래스 기능을 구현하는 메서드

클래스 내부에서 사용하는 멤버 함수, 멤버 변수를 사용하여 클래스의 기능 구현

- 메서드 구현하기
    
    ```java
    public class Student {
    	int studentID;
    	String studentName;
    	int grade;
    	String address;
    
    	// 학생의 이름을 반환하는 메서드
    	public String getStudentName() {
    		return studentName;
    	}
    
    	public void setStudentName(String name) {
    				                   // 학생 이름을 매개변수로 전달
    		studentName = name;
    	}
    }
    ```
    

### 자바의 이름 짓기 규약

1. 클래스의 이름은 대문자로 시작
2. public 클래스는 단 하나이고 public 클래스 이름과 자바 파일 이름은 같아야 함
3. 패키지의 이름은 소문자
4. 변수와 메서드 이름은 소문자로 시작하여 중간에 새 단어로 바뀔 때마다 대문자로 써줌 → 낙타 표기법

## import

1. 자바의 라이브러리 패키지의 클래스를 사용할 때
- import java.util.Scanner;

2. 사용자의 다른 패키지 안의 클래스를 사용할 때 
- import 패키지명.*;
    
    *: 패키지의 모든 클래스 사용
    
- import 패키지명.클래스명;
    
    패키지의 해당 클래스만 사용
    

## 클래스와 인스턴스

### main() 함수

자바 가상 머신(JVM)이 프로그램을 시작하기 위해 호출하는 함수

### main() 함수에서 클래스 사용하는 방법

1. 생성한 클래스 내부에 main() 함수를 만드는 방법
- 클래스 내부에 main() 함수를 만들면  해당 클래스가 프로그램의 시작 클래스가 된다.

2. 외부에 테스트용 클래스를 만들어 사용하는 방법
- 실행하고 싶은 클래스와 같은 패키지에 테스트용 클래스를 생성하여 클래스를 생성하는 코드를 구현하면 된다.

### 클래스 생성하기

- 클래스형 변수명 = new 생성자;
    
    클래스 자료형 변수를 선언하고 new 예약어로 생성자를 호출하여 새로운 클래스를 생성한다.
    

<aside>
💡 클래스 생성 ⇒ 클래스를 사용할 수 있도록 메모리 공간(힙 메모리)을 할당받는 것

</aside>

### 객체

의사나 행위가 미치는 대상

객체 배열 생성

클래스형 변수명 = new 클래스형[ ];

### 인스턴스

클래스가 메모리 공간에 생성된 상태

### 인스턴스 사용방법

- 참조 변수 사용
- 참조변수.멤버 변수 / 참조변수.메서드

### 힙 메모리

프로그램에서 사용하는 동적 메모리 공간

동적으로 할당되며 사용이 끝나면 메모리를 해제해줘야함

### 참조 변수와 참조 값

- 참조 변수 : 힙 메모리에 생성된 인스턴스
    
    힙 메모리에 생성된 인스턴스 메모리의 주소가 저장됨
    
- 참조 값 : 클래스 이름@주소 값(해시 코드 값)
    
    자바 가상 머신에서 객체가 생성됐을 때 생성된 객체에 할당하는 가상 주소 값
    

## 생성자

클래스를 처음 만들 때 멤버 변수나 상수를 초기화하는 것

- 디폴트 생성자
- 생성자가 없는 클래스는 클래스 파일을 컴파일할 때 자바 컴파일러에서 자동으로 생성자를 만들어줌
    
    매개변수 및 구현코드가 없음
    

### 생성자 만들기

```java
package constructor;

public class Person {
	String anme;
	float height;
	float weight;
	
	public Person(String pname) {  //pname을 매개변수로 입력받아 Person 클래스를 생성하는 생성자
		name = pname;
	}
}
```

생성자를 구현한 경우, 디폴트 생성자는 사용자가 직접 추가로 구현해줘야 함

### 생성자 오버로드(constructor overload)

클래스에 생성자가 두 개 이상 제공되는 경우

메서드 이름이 같고 매개변수만 다른 경우

## this 예약자

생성된 인스턴스 스스로를 가리키는 예약어

### 생성자에서 this로 다른 생성자 호출하기

```java
class Person {
	String name;
	int age;

	Person() {
		this("이름없음", 1); // this를 사용해서 Person(String int) 생성자 호출
	}
	
	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
}

public class CallAnotherConst {
	public static void main(String[] args) {
		Person noName = new Person();
		System.out.println(noName.name);
		System.out.println(noName.age);
	}
}
```

- this를 사용하여 생성자를 호출하는 코드 위에 다른 코드를 넣을 수 없음

### 자신의 주소 반환하기

```java
class Person {
	String name;
	int age;

	Person() {
		this("이름없음", 1); // this를 사용해서 Person(String int) 생성자 호출
	}
	
	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	Person returnItSelf() {
		return this;
	}
}

public class CallAnotherConst {
	public static void main(String[] args) {
		Person noName = new Person();
		System.out.println(noName.name);
		System.out.println(noName.age);

		Person p = noName.returnItSelf();
		System.out.println(p);
		System.out.println(noName);
	}
}
```

- 클래스 자료형과 상관없이 클래스내에서 this를 사용하면 자신의 주소 값을 반환할 수 있다.

## 멤버변수의 초기화

변수를 선언하고 처음으로 값을 저장하는 것

- 멤버변수(클래스변수와 인스턴스변수)의 초기화는 선택적
- 초기화하지 않아도 기본값으로 초기화가 이루어짐

- 지역변수의 초기화는 필수적

### 초기화 방법

1. 명시적 초기화
- 변수를 선언과 동시에 초기화하는 것
    
    자료형 변수명 = 값;
    

2. 생성자
- 제어자 메서드이름 () { }

3. 초기화 블록
- 클래스 초기화 블록
- 인스턴스 초기화 블럭

```java
class InitBlock {
	static { // 클래스 초기화 블럭
	{ 
		// 인스턴스 초기화 블럭
	}
}
```

### 초기화 시기와 순서

1. 클래스 변수의 초기화 시점
- 클래스가 처음 로딩될 때 한번 초기화
    
    기본값 → 명시적초기화 → 클래스 초기화 블록
    

2. 인스턴스 변수의 초기화 시점
- 인스턴스가 생성될 때마다 각 인스턴스별로 초기화
    
    기본값 → 명시적초기화 → 인스턴스 초기화 블록
    

## 제어자(modifier)

클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미 부여

하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근 제어자는 단 하나만 사용가능

- 접근 제어자
- public, private, default, protected

- 그 외 제어자
- static, final, abstract, native, transient, synchronized, volatile, strictfp

## static 변수

클래스에서 공통으로 사용하는 정적 변수

### 선언하기

static 자료형 변수명;

### 특징

- 클래스 내부에서 선언
- 프로그램이 실행되고 딱 한 번 메모리 공간이 할당되고 그 값을 모든 인스턴스가 공유
- 인스턴스가 생성되지 않아도 사용 가능
- 클래스 이름으로 직접 참조
- 클래스 메서드 내부에서는 인스턴스 사용 불가

## 객체지향 프로그래밍 언어의 특징

1. 캡슐화(Encapsulation)
- 데이터와 데이터를 처리하는 함수를 하나로 묶는 것

2. 정보 은닉(INformation Hiding)
- 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통한 접근을 허용하는 것

3. 추상화(Abstraction)
- 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화하는 것

4. 상속성(Inheritance)
- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

5. 다형성(Polymorphism)
- 하나의 메세지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

## 상속(inheritance)

### 상속의 효과

- 부모 클래스 재사용해 자식 클래스 빨리 개발 가능
- 반복된 코드 중복 줄임
- 유지 보수 편리성 제공
- 객체 다형성 구현 가능

### 클래스 상속 문법

- extends 예약어 사용

```java
class B extands A {
}
```

- 부모 클래스 : A
- 자식 클래스 : B
- 클래스 A가 가지고 있는 속성이나 기능을 추가로 확항하여  클래스 B 구현

### 상위 클래스 변수 사용하기

- protected 예약어 사용
- 외부에서 사용할 수 있도록 get(), set() 설정

### 하위 클래스 생성

1. 상위 클래스를 상속받은 하위 클래스가 생성될 때 반드시 상위 클래스의 생성자가 먼저 호출
2. 상위 클래스 생성자가 호출될 때 상위 클래스의 멤버 변수가 멤모리에 생성
3. 상위 클래스의 변수가 먼저 생성되기 때문에 하위 클래스에서 사용할 수 있음

단, 부모 클래스의  private 변수는 자식 클래스에서 접근할 수 없음

### super

하위 클래스에서 상위 클래스를 호출하는 예약어

상위 클래스에 선언한 멤버 변수나 메서드를 하위 클래스에서 참조할 때 사용

### 묵시적 클래스 형 변환

선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근할 수 있음

- 다운캐스팅
- 상위 클래스형 변수명 = new 하위 클래스형;
    
    상위 클래스형 멤버 변수와 메서드만 사용가능
    

- 업 캐스팅
- 하위 클래스형 변수명 = (상위 클래스형) 상위 클래스 변수명;

### 메서드 오버라이딩

상위 클래스에서의 메서드를 하위 클래스에서 재정의 하는 경우

반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형이 같아야 함

- @Override 사용

## 다형성(polymorphism)

하나의 코드가 여러 자료형으로 구현되어 실행되는 것

### 다운 캐스팅

상위 클래스로 형 변환된 하위 클래스를 다시 원래 자료형으로 형 변환하는 것

### instanceof

다운 캐스팅 하기 전 상위 클래스로 형 변환된 인스턴스의 원래 자료형을 확인하는 예약어

```java
Animal hAnimal = new Human();
if(hAnimal instanceof Human) {
	Human human = (Human)hAnimal;
}
```

- 왼쪽 변수의 인스턴스형이 오른쪽 클래스 자료형인지 확인할 수 있음

## 추상 클래스

구체적이지 않은 클래스나 메서드, 변수를 선언할 때 사용

1. 추상 클래스
- 항상 추상 메서드를 포함함
    
    접근 제어자 abstract class 클래스명 {    }
    
    인스턴스로 생성할 수 없음
    

2. 추상 메서드
- 함수의 구현 코드가 없는 메서드
    
    접근 제어자 abstract void 메서드명();
    
    하위 클래스에서도 구현 내용을 공유할 메서드
    

### 추상 클래스를 만드는 이유

상속을 하기 위해 만든 클래스이다.

### 템플릿 메서드

- 추상 클래스를 사용하여 구현할 수 있는 디자인 패턴
- 메서드 실행 순서와 시나리오 정의
- 로직 흐름이 이미 정해져 있는 프레임워크에서 많이 사용하는 기본 구현 방법
- final 예약어를 사용해 선언
- 모든 하위 클래스가 공통으로 사용하고 코드를 변경하면 안되는 메서드를 템플리 메서드로 설정

## final

### 사용 위치에 따른 특징

1. 변수
- 상수를 의미함

2. 메서드
- 하위 클래스에서 재정의할 수 없음

3. 클래스
- 상속할 수 없음
    
## 인터페이스

클래스 혹은 프로그램이 제공하는 기능을 명시적으로 선언하는 역할

구현 코드가 없음

### 인터페이스 구성요소

1. 추상 메서드
- 디폴트 메서드 - default
- 구현 코드까지 작성한 메서드
    
    인터페이스를 구현한 클래스에 기본적으로 제공할 메서드
    
- 정적 메서드 - static
- 인스턴스 생성과 상관없이 사용할 수 있는 메서드

2. 상수

### 인터페이스의 역할

인터페이스를 구현한 클래스가 어떤 기능의 메서드를 제공하는지 명시하는 것

## 접근제어자

예약어를 사용해 클래스 내부의 변수나 메서드, 생성자에 대한 접근 권한 지정

1. public
- 외부 클래스 어디에서나 접근가능

2. private
- 같은 클래스 내부에서만 접근 가능

3. protected
- 같은 패키지 내부와 상속 관계의 클래스에서만 접근 가능

4. default
- 같은 패키지 내부에서만 접근 가능

## 선언위치에 따른 변수의 종류

1. 지역 변수(로컬 변수, local variable) : 함수나 메서드 안에서만 사용
- 함수나 메서드 내부에 선언 - 스택

2. 멤버 변수(인스턴스 변수, instance variable) : 클래스 안에서만 사용
- 클래스 멤버 변수로 선언 - 힙

3. static 변수(클래스 변수, class variable) : 여러 인스턴스에서 공통으로 사용
- static 예약어를 사용하여 클래스 내부에 선언 - 데이터 영역
    
    
- 정의
    
    static 자료형 변수명;
    

## 용어 정리

1. 객체 : 객체 지향 프로그램의 대상, 생성된 인스턴스
2. 클래스 : 객체를 프로그래밍하기 위해 코드로 만든 상태
3. 인스턴스 : 클래스가 메모리에 생성된 상태
4. 멤버 변수 : 클래스의 속성, 특성
5. 메서드 : 멤버 변수를 이용하여 클래스의 기능 구현
6. 참조 변수 : 메모리에 생성된 인스턴스를 가르키는 변수
7. 참조 값 : 생성된 인스턴스의 메모리 주소 값

## Object  클래스

모든 자바 클래스의 최상위 클래스

### Object 클래스에서 사용되는 메서드

1. String toString() 
- 객체를 문자열로 표현하고 반환
    
    재정의하여 객체에 대한 설명이나 특정 멤버 변수 값 반환
    

2. boolean equals(Obejct obj)
- 두 인스턴스가 동일한지 여부 반환
    
    재정의하여 논리적으로 동일한 인스턴스임을 정의할 수 있음
    
3. int hashCode()
- 객체의 해시 코드 값 반환
    
    해시 : 정보를 저장하거나 검색할 때 사용하는 자료 구조
    
    해시 함수는 객체의 키 값을 매개변수 값으로 넣으면 그 객체가 저장되어야 할  위치나 저장된 해시 테이블 주소를 반환함
    

** equlas() 메서드를 재정의하면 hashCode() 메서드도 재정의해야함

1. Object clone()
- 객체를 복제하여 동일한 멤버 변수 값을 가진 새로운 인스턴스 생성

2. Class getClass()
- 객체의 Class 클래스 반환

3. void finalize()
- 인스턴스가 힙 메모리에서 제거될 때 가비지 컬렉터에 의해 호출되는 메서드
    
    네트워크 연결 해제, 열려있는 파일 스트림 해제 등 구현
    

4. void wait()
- 멀티스레드 프로그램에서 사용하는 메서드
    
    스레드를 기다리는 상태(non runnable)로 만듬
    

5. void notify()
- wait() 메서드에 의해 기다리고 있는 스레드를 실행 가능한 상태로 가져옴